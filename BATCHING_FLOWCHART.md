# 请求批处理流程图

## 整体流程

```
客户端请求                    Worker                        AI Provider
    │                          │                               │
    ├─ 请求1 (requestId: abc) ─┤                               │
    │   [t=0ms]               │                               │
    │                         ├─ 创建批次                      │
    │                         ├─ 启动300ms定时器              │
    │                         │                               │
    ├─ 请求2 (requestId: abc) ─┤                               │
    │   [t=50ms]              │                               │
    │                         ├─ 添加到批次                    │
    │                         ├─ 重置定时器                    │
    │                         │                               │
    ├─ 请求3 (requestId: abc) ─┤                               │
    │   [t=100ms]             │                               │
    │                         ├─ 添加到批次                    │
    │                         ├─ 重置定时器                    │
    │                         │                               │
    │                         │  [t=400ms 定时器触发]          │
    │                         │                               │
    │                         ├─ 合并3个请求                   │
    │                         │  "Hello\n---\nWorld\n---\nHi"  │
    │                         │                               │
    │                         ├─────── 发送合并请求 ──────────▶│
    │                         │                               │
    │                         │                               ├─ 处理请求
    │                         │                               │
    │                         │◀────── 返回合并响应 ───────────┤
    │                         │  "你好\n---\n世界\n---\n嗨"     │
    │                         │                               │
    │                         ├─ 拆分响应                      │
    │                         │  ["你好", "世界", "嗨"]         │
    │                         │                               │
    │◀─── 响应1: "你好" ───────┤                               │
    │                         │                               │
    │◀─── 响应2: "世界" ───────┤                               │
    │                         │                               │
    │◀─── 响应3: "嗨" ─────────┤                               │
    │                         │                               │
```

## RequestId 识别流程

```
请求到达
   │
   ├─ 检查 Header: X-Request-Id
   │   ├─ 存在? → 使用该值
   │   └─ 不存在 ↓
   │
   ├─ 检查 Header: cf-ray (Cloudflare Ray ID)
   │   ├─ 存在? → 使用该值
   │   └─ 不存在 ↓
   │
   ├─ 检查请求体: metadata.requestId
   │   ├─ 存在? → 使用该值
   │   └─ 不存在 ↓
   │
   ├─ 检查请求体: requestId
   │   ├─ 存在? → 使用该值
   │   └─ 不存在 ↓
   │
   └─ 生成 UUID → 使用新生成的值
```

## 批处理决策树

```
请求进入
   │
   ├─ 批处理全局禁用? (batchConfig.enabled = false)
   │   ├─ 是 → 直接处理
   │   └─ 否 ↓
   │
   ├─ 请求禁用批处理? (X-Enable-Batching: false)
   │   ├─ 是 → 直接处理
   │   └─ 否 ↓
   │
   ├─ 流式响应? (stream: true)
   │   ├─ 是 → 直接处理
   │   └─ 否 ↓
   │
   ├─ 包含用户消息?
   │   ├─ 否 → 直接处理
   │   └─ 是 ↓
   │
   └─ 进入批处理队列
       │
       ├─ 该 requestId 已有批次?
       │   ├─ 是 → 添加到现有批次
       │   └─ 否 → 创建新批次
       │
       ├─ 批次大小 >= maxBatchSize?
       │   ├─ 是 → 立即处理
       │   └─ 否 → 等待定时器
       │
       └─ 定时器触发 → 处理批次
```

## 消息合并流程

```
原始请求:
┌─────────────────────┐
│ 请求1                │
│ System: "你是翻译..."│
│ User: "Hello"       │
└─────────────────────┘

┌─────────────────────┐
│ 请求2                │
│ System: "你是翻译..."│
│ User: "World"       │
└─────────────────────┘

┌─────────────────────┐
│ 请求3                │
│ System: "你是翻译..."│
│ User: "How are you?"│
└─────────────────────┘

         ↓ 合并

┌─────────────────────────────┐
│ 合并后的请求                 │
│ System: "你是翻译..."        │
│ User: "Hello                │
│                             │
│       ---                   │
│                             │
│       World                 │
│                             │
│       ---                   │
│                             │
│       How are you?"         │
└─────────────────────────────┘
```

## 响应拆分流程

```
AI 响应:
┌─────────────────────────────┐
│ "你好                        │
│                             │
│  ---                        │
│                             │
│  世界                       │
│                             │
│  ---                        │
│                             │
│  你好吗？"                   │
└─────────────────────────────┘

         ↓ 拆分（按 \n\n---\n\n）

┌──────────┐  ┌──────────┐  ┌──────────┐
│ 响应1     │  │ 响应2     │  │ 响应3     │
│ "你好"   │  │ "世界"   │  │ "你好吗？"│
└──────────┘  └──────────┘  └──────────┘
     │             │             │
     ├──────┬──────┴──────┬──────┘
     ↓      ↓             ↓
   客户端1  客户端2       客户端3
```

## Token 使用对比

### 不使用批处理
```
┌─────────────────────┐
│ 请求1                │
│ System: 500 tokens  │  ← 重复
│ User:    10 tokens  │
│ Total:  510 tokens  │
└─────────────────────┘

┌─────────────────────┐
│ 请求2                │
│ System: 500 tokens  │  ← 重复
│ User:    10 tokens  │
│ Total:  510 tokens  │
└─────────────────────┘

┌─────────────────────┐
│ 请求3                │
│ System: 500 tokens  │  ← 重复
│ User:    10 tokens  │
│ Total:  510 tokens  │
└─────────────────────┘

总计: 1,530 tokens
```

### 使用批处理
```
┌──────────────────────────┐
│ 合并请求                  │
│ System: 500 tokens       │  ← 只需一次
│ User:    30 tokens       │  (含分隔符)
│ Total:  530 tokens       │
└──────────────────────────┘

总计: 530 tokens
节省: 1,000 tokens (65%)
```

## 批处理状态机

```
                    [IDLE]
                      │
                      │ 收到第一个请求
                      ↓
    ┌──────────[ACCUMULATING]◀──────┐
    │             │    ↑             │
    │ 达到最大     │    │ 收到新请求  │
    │ 批次大小     │    └─────────────┘
    │             │
    │             │ 定时器超时
    ↓             ↓
[PROCESSING]      │
    │             │
    │ 发送请求    │
    ↓             │
[WAITING_RESPONSE]│
    │             │
    │ 收到响应    │
    ↓             │
[SPLITTING]       │
    │             │
    │ 分发响应    │
    ↓             ↓
[COMPLETED] ───▶ [IDLE]
    │
    └─ 清理批次数据
```

## 错误处理流程

```
批处理执行
   │
   ├─ 合并请求成功?
   │   ├─ 否 → 单独处理每个请求
   │   └─ 是 ↓
   │
   ├─ 发送到 AI 成功?
   │   ├─ 否 → 所有请求返回错误
   │   └─ 是 ↓
   │
   ├─ 响应拆分成功?
   │   ├─ 否 → 所有请求返回完整响应
   │   └─ 是 ↓
   │
   └─ 分发响应给各个请求
       │
       └─ 记录成功日志
```

## 并发场景

```
时间线（同一 requestId）:

t=0ms    │───── 请求1 到达 ─────┐
         │                     ├─ 创建批次A, 设置定时器(300ms)
         │                     │
t=50ms   │───── 请求2 到达 ─────┤
         │                     ├─ 加入批次A, 重置定时器
         │                     │
t=100ms  │───── 请求3 到达 ─────┤
         │                     ├─ 加入批次A, 重置定时器
         │                     │
t=400ms  │                     ├─ 定时器触发
         │                     ├─ 处理批次A (3个请求)
         │                     │
t=450ms  │───── 请求4 到达 ─────┐
         │                     ├─ 创建批次B, 设置定时器
         │                     │
t=750ms  │                     ├─ 定时器触发
         │                     └─ 处理批次B (1个请求)


时间线（不同 requestId）:

t=0ms    │─── 请求1 (id: A) ───┐  │─── 请求2 (id: B) ───┐
         │                    │  │                    │
         │           批次A ←──┘  │           批次B ←──┘
         │             │         │             │
t=300ms  │             └─处理    │             └─处理
         │                       │
         │     (独立处理，不会合并)
```

## 客户端集成模式

### 模式1：快速连续发送
```javascript
const id = 'batch-1';

// 立即发送所有请求
Promise.all([
  fetch(url, { headers: { 'X-Request-Id': id }, body: req1 }),
  fetch(url, { headers: { 'X-Request-Id': id }, body: req2 }),
  fetch(url, { headers: { 'X-Request-Id': id }, body: req3 })
]);
// ✓ 会被合并（在300ms窗口内）
```

### 模式2：延迟发送
```javascript
const id = 'batch-2';

fetch(url, { headers: { 'X-Request-Id': id }, body: req1 });
await sleep(500);  // ❌ 超过300ms窗口
fetch(url, { headers: { 'X-Request-Id': id }, body: req2 });
// ✗ 不会被合并
```

### 模式3：异步收集
```javascript
const id = 'batch-3';

async function processItems(items) {
  const promises = items.map(item => 
    fetch(url, { 
      headers: { 'X-Request-Id': id },
      body: JSON.stringify({ messages: [{ role: 'user', content: item }] })
    })
  );
  
  return Promise.all(promises);
}

// ✓ 会被合并（并发发送）
await processItems(['Hello', 'World', 'Test']);
```
